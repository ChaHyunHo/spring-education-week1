## Spring education Week1

#### 1. 왜 스프링일까?
스프링 프레임워크는 자바(Java) 기반의 애플리케이션을 개발하는 데 필요한 거의 모든 것을 지원하는 오픈소스 프레임워크입니다. 단순히 웹 개발뿐만 아니라, 데이터 처리, 보안, 배치(batch) 작업 등 기업 환경의 복잡한 시스템을 구축하는 데 필요한 포괄적인 프로그래밍 및 설정 모델을 제공합니다.

스프링의 핵심 철학은 "좋은 객체 지향 설계"를 돕는 것입니다. 복잡하고 무거웠던 과거의 자바 개발 방식(특히 EJB)을 비판하며, 개발자들이 순수한 자바 객체(POJO)를 사용해 비즈니스 로직에만 집중할 수 있도록 도와줍니다.


#### POJO(Plain Old Java Object)
**POJO**는 말 그대로 "평범한 옛날 자바 객체"를 의미합니다.

과거의 **EJB와 같은 특정 기술 프레임워크에 종속된 객체들은 해당 프레임워크의 특정 클래스를 상속(`extends`)하거나 인터페이스를 구현(`implements`)해야만 했습니다**. 이로 인해 코드가 프레임워크에 심하게 종속되고, 테스트가 어려워지는 문제가 있었습니다.

**POJO**는 이러한 종속성이 없는, 순수 자바 문법으로만 만들어진 객체입니다.

```
// 이것이 바로 POJO입니다.
// 특정 프레임워크의 클래스를 상속하거나 인터페이스를 구현하지 않았습니다.
public class Member {
    private String name;
    private int age;

    // Getters and Setters...
}
```
스프링의 위대함은 바로 이 POJO를 기반으로 동작한다는 점입니다. 스프링은 POJO 객체를 가져다가 IoC 컨테이너에 등록하고, AOP를 적용하는 등 강력한 기능을 부여합니다. 개발자는 프레임워크가 아닌, 순수한 비즈니스 로직을 담은 POJO에만 집중하면 됩니다.


#### 스프링의 역사: 고통에서 탄생한 혁신
- **~2000년대 초반 (EJB의 시대):** 기업용 자바 개발의 표준은 **EJB(Enterprise JavaBeans)**였습니다. EJB는 강력한 기능을 제공했지만, 너무 복잡하고, 무거웠으며, 비싼 WAS(Web Application Server)를 필요로 했습니다. 또한, **코드가 EJB 프레임워크에 심하게 종속되는 문제**가 있었습니다.
- **2002년 (새로운 시대의 서막):** 개발자 **로드 존슨(Rod Johnson)**이 `Expert One-on-One J2EE Design and Development`라는 책을 출간합니다. 그는 이 책에서 EJB의 문제점을 신랄하게 비판하고, POJO와 DI를 기반으로 한 더 가볍고 단순한 프레임워크의 필요성을 역설했습니다. 이 책에 담긴 3만 줄의 코드가 바로 **스프링 프레임워크의 시작**이었습니다.
- **2004년 (스프링 1.0 출시):** EJB의 대안으로 공식 출시되며 폭발적인 인기를 얻기 시작합니다.
- **2010년대 (스프링 부트의 등장):** 스프링 프레임워크 자체도 설정이 복잡하다는 의견이 많아졌습니다. 이를 해결하기 위해 **스프링 부트(Spring Boot)**가 등장했습니다. **스프링 부트는 "Convention over Configuration(설정보다 관례)"** 철학을 바탕으로, 개발자가 복잡한 설정을 하지 않아도 최소한의 설정으로 빠르게 애플리케이션을 실행할 수 있도록 도와줍니다. 오늘날 대부분의 스프링 프로젝트는 스프링 부트를 기반으로 시작합니다.


#### 스프링의 3대 핵심 특징

- **IoC (Inversion of Control) / DI (Dependency Injection): 제어의 역전 / 의존성 주입**
    - **과거:** 개발자가 직접 객체를 생성하고 의존성을 연결했습니다. (예: `Controller`가 `new Service()`를 직접 생성)
    - **스프링:** 객체의 생성과 생명주기 관리를 스프링 컨테이너가 대신해 줍니다. 개발자는 필요한 객체를 선언만 하면, 스프링이 알아서 주입(Injection)해 줍니다.
    - "레고 블록"을 조립할 때, 필요한 블록을 직접 찾는 것이 아니라, "레고 마스터(스프링 컨테이너)"에게 "이런 모양의 블록이 필요해!"라고 요청하면 알아서 가져다주는 것과 같습니다. 이로 인해 부품(객체) 간의 결합도(coupling)가 낮아지고, 유연하고 확장 가능한 구조가 됩니다.
- **AOP (Aspect-Oriented Programming): 관점 지향 프로그래밍**
    - 애플리케이션 전반에 걸쳐 공통적으로 적용되는 기능(예: 로깅, 보안, 트랜잭션)을 비즈니스 로직과 분리하여 모듈화하는 기술입니다.
    - 메인 비즈니스 코드에는 영향을 주지 않으면서, 필요한 부분에 공통 기능을 '끼워 넣는' 방식으로 동작합니다.
- **PSA (Portable Service Abstraction): 일관된 서비스 추상화**
    - 데이터베이스 접근 방식(JPA, JDBC 등), 트랜잭션 처리 등 다양한 기술 구현체들을 스프링이 제공하는 일관된 방식으로 사용할 수 있도록 돕습니다.
    - 덕분에 개발자는 기술이 바뀌더라도 코드를 거의 수정하지 않고 기술을 교체할 수 있습니다.



#### 톰캣, 서블릿, 그리고 스프링 컨테이너의 구조
우리가 스프링 부트로 웹 애플리케이션을 실행하면, 내부에서는 다음과 같은 구조로 요청을 처리합니다.
```
// 요청의 흐름 
Api Request → Tomcat → Servlet(DispatcherServlet) → Spring Container(Controller)
```

1. **톰캣 (Tomcat) - 웹 서버 & 서블릿 컨테이너**
    - 스프링 부트는 **내장 톰캣(Embedded Tomcat)**을 가지고 있습니다.
    - **역할:** 클라이언트(웹 브라우저)로부터 오는 **HTTP 요청을 가장 먼저 받는 관문**입니다. 마치 건물의 "안내 데스크"와 같습니다.
    - 톰캣은 들어온 요청을 분석하여, 이 요청을 처리할 수 있는 애플리케이션(서블릿)에게 전달합니다.

1. **서블릿 (Servlet) - DispatcherServlet**
    - **역할:** 톰캣으로부터 요청을 넘겨받는 **스프링의 중앙 통제실** 또는 "교통 경찰"입니다.
    - 스프링 웹 애플리케이션에서는 모든 요청이 일단 `DispatcherServlet`이라는 단 하나의 서블릿으로 모입니다.
    - `DispatcherServlet`은 요청 URL(예: `/members/1`)을 보고, 이 요청을 처리할 담당자(Controller)가 누구인지 찾아주는 역할을 합니다. 실제 로직을 처리하지 않고, 적절한 곳에 **요청을 위임(dispatch)**합니다.

1. **스프링 컨테이너 (Spring Container) - ApplicationContext**
    - **역할:** 스프링의 **핵심 엔진**이자 **POJO 객체들의 공장 겸 관리소**입니다.
    - `@Controller`, `@Service`, `@Repository` 등 스프링이 관리하는 모든 객체(**Bean**)들이 이곳에 등록되어 있습니다.
    - `DispatcherServlet`이 "이 URL 요청 누가 처리해?"라고 물으면, 스프링 컨테이너는 등록된 Bean 중에서 적절한 `Controller`와 그 안의 메서드를 찾아 연결해 줍니다.
    - 이후 `Controller`는 비즈니스 로직 처리를 `Service`에 위임하고, `Service`는 데이터 처리를 `Repository`에 위임하는 식으로 작업이 연쇄적으로 일어납니다. 이 모든 객체 간의 관계(의존성)는 스프링 컨테이너가 관리하고 연결(주입)해 줍니다.

결론적으로, **톰캣**이 요청을 받고, 스프링의 `DispatcherServlet`이 요청을 분류하며, 실제 작업은 **스프링 컨테이너**가 관리하는 여러 **Bean(POJO 객체)**들이 협력하여 처리하는 구조입니다. 이 구조 덕분에 개발자는 비즈니스 로직에만 집중할 수 있습니다.


**잠깐, 서블릿(Servlet)이란 무엇일까요?**

앞서 `DispatcherServlet`이라는 용어가 등장했는데, 여기서 서블릿(Servlet)이란 무엇인지 짚고 넘어가겠습니다.

- **서블릿(Servlet)은** 서버 측에서 실행되는 작은 자바 프로그램을 의미합니다.
  (Server + Applet의 합성어)

과거에는 클라이언트의 요청에 따라 웹 페이지의 내용이 바뀌어야 할 때마다 새로운 HTML 파일을 일일이 만들어야 했습니다. 이는 매우 비효율적이었습니다.

서블릿은 이러한 **정적인(static) 웹의 한계를 극복**하기 위해 등장했습니다.

**서블릿의 핵심 역할:**

1. **동적(Dynamic) 웹 페이지 생성:**
    - 서블릿은 자바 코드를 통해 동적으로 HTML을 생성할 수 있습니다.
    - 예를 들어, 사용자의 요청에 따라 데이터베이스에서 정보를 가져와 다른 내용의 HTML 페이지를 만들어 응답할 수 있습니다. (예: "홍길동님, 환영합니다!" vs "이순신님, 환영합니다!")
2. **클라이언트 요청 처리:**
    - 클라이언트(웹 브라우저)가 보낸 `GET`, `POST`와 같은 HTTP 요청을 읽고, 그에 맞는 비즈니스 로직을 수행합니다.

**즉, 서블릿은 클라이언트의 요청을 받아 자바 코드로 비즈니스 로직을 처리하고, 그 결과를 동적인 HTML로 만들어 클라이언트에게 응답해주는 기술입니다.**

**스프링과 서블릿의 관계:**

스프링 프레임워크가 등장하기 전에는 개발자들이 여러 개의 서블릿을 직접 만들고, 각 URL 요청을 어떤 서블릿이 처리할지 `web.xml`이라는 파일에 일일이 설정해야 했습니다.

하지만 스프링에서는 **`DispatcherServlet`**이라는 **단 하나의 서블릿**이 모든 요청을 **대표**로 받습니다. 그리고 실제 작업은 `DispatcherServlet`이 스프링 컨테이너에 있는 컨트롤러(Controller)에게 위임하는 방식으로 동작합니다.

덕분에 개발자는 서블릿을 직접 구현하는 번거로움 없이, 컨트롤러 로직 개발에만 집중할 수 있게 되었습니다.